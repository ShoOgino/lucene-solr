package org.apache.lucene.search;

/**
 * Copyright 2004 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;

/**
 * The Scorer for DisjunctionMaxQuery's.  The union of all documents generated by the the subquery scorers
 * is generated in document number order.  The score for each document is the maximum of the scores computed
 * by the subquery scorers that generate that document, plus tieBreakerMultiplier times the sum of the scores
 * for the other subqueries that generate the document.
 * @author Chuck Williams
 */
class DisjunctionMaxScorer extends Scorer {

    /* The scorers for subqueries that have remaining docs, kept sorted by number of next doc. */
    private ArrayList subScorers = new ArrayList();

    /* Multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result. */
    private float tieBreakerMultiplier;

    private boolean more = false;          // True iff there is a next document
    private boolean firstTime = true;      // True iff next() has not yet been called

    /* Comparator to sort subScorers according to the document number of next document */
    private static class DisjunctionMaxClauseComparator implements Comparator {

        /* Scorers have all been positioned at their next document already */
        public int compare(Object o1, Object o2) {
            if (o1 instanceof Scorer && o2 instanceof Scorer) {
                Scorer s1 = (Scorer) o1;
                Scorer s2 = (Scorer) o2;

                return s1.doc() - s2.doc();
            }
            else {
                throw new ClassCastException("Objects not of the type 'Scorer'");
            }
        }

        /* Compatible equality */
        public boolean equals(Scorer s1, Scorer s2) {
            return s1.doc() == s2.doc();
        }

     }

    /* Fixed instance of the comparator to reuse */
    private static DisjunctionMaxClauseComparator subScorerComparator = new DisjunctionMaxClauseComparator();

    /** Creates a new instance of DisjunctionMaxScorer
     * @param similarity -- not used since our definition involves neither coord nor terms directly */
    public DisjunctionMaxScorer(float tieBreakerMultiplier, Similarity similarity) {
        super(similarity);
        this.tieBreakerMultiplier = tieBreakerMultiplier;
    }

    /** Add the scorer for a subquery
     * @param scorer the scorer of a subquery of our associated DisjunctionMaxQuery
     */
    public void add(Scorer scorer) throws IOException {
        if ( scorer.next() ) {       // Initialize and retain only if it produces docs
            subScorers.add(scorer);
            more = true;
        }
    }

    /* First time initialization.  Sort subScorers. */
    private void init() {
        sortSubScorers();
        firstTime = false;
    }

    /* Sort subScorers in order of document number of next document to be generated */
    private void sortSubScorers() {
        Scorer[] sorted = (Scorer[]) subScorers.toArray(new Scorer[subScorers.size()]);
        Arrays.sort(sorted, subScorerComparator);
        for (int i=0; i<sorted.length; i++) subScorers.set(i, sorted[i]);
    }

    /** Generate the next document matching our associated DisjunctionMaxQuery.
     * @return true iff there is a next document
     */
    public boolean next() throws IOException {
        if ( !more ) return false;
        if ( firstTime ) {
            init();
            return true;   // more would have been false if no subScorers had any docs
        }
        // Increment all generators that generated the last doc and incrementally re-sort.
        int lastdoc = ((Scorer) subScorers.get(0)).doc();
        do {
            if ( ((Scorer) subScorers.get(0)).next() ) {
                Scorer s = (Scorer) subScorers.get(0);
                int snextdoc = s.doc(), i=1;
                for (; i<subScorers.size() && snextdoc > ((Scorer) subScorers.get(i)).doc(); i++)
                    subScorers.set(i-1, subScorers.get(i));
                if ( i!=1 ) subScorers.set(i-1, s);
            } else {
                subScorers.remove(0);
                if ( subScorers.isEmpty() ) return (more = false);
            }
        } while ( ((Scorer) subScorers.get(0)).doc()==lastdoc );
        return true;
    }

    /** Determine the current document number.  Initially invalid, until {@link #next()} is called the first time.
     * @return the document number of the currently generated document
     */
    public int doc() {
        return ((Scorer) subScorers.get(0)).doc();
    }

    /** Determine the current document score.  Initially invalid, until {@link #next()} is called the first time.
     * @return the score of the current generated document
     */
    public float score() throws IOException {
        float max = ((Scorer) subScorers.get(0)).score(), sum = max;
        for (int i = 1, doc = ((Scorer) subScorers.get(0)).doc(); i < subScorers.size() && ((Scorer) subScorers.get(i)).doc() == doc; i++) {
            float sub = ((Scorer) subScorers.get(i)).score();
            sum += sub;
            max = Math.max(max, sub);
        }
        return max + (sum - max)*tieBreakerMultiplier;
    }

    /** Advance to the first document beyond the current whose number is greater than or equal to target.
     * @param target the minimum number of the next desired document
     * @return true iff there is a document to be generated whose number is at least target
     */
    public boolean skipTo(int target) throws IOException {
        int i=0;
        while ( i<subScorers.size() ) {
            if ( ((Scorer) subScorers.get(i)).doc() < target ) {
                if ( ((Scorer) subScorers.get(i)).skipTo(target) ) i++;
                else subScorers.remove(i);
            } else i++;
        }
        if ( i == 0 ) return false;
        sortSubScorers();
        return true;
    }

    /** Explain a score that we computed.  UNSUPPORTED -- see explanation capability in DisjunctionMaxQuery.
     * @param doc the number of a document we scored
     * @return the Explanation for our score
     */
    public Explanation explain(int doc) throws IOException {
        throw new UnsupportedOperationException();
    }

}

/***************************************************************************
 Implementation notes from http://issues.apache.org/jira/browse/LUCENE-323


 There is an issue with the MaxDisjunctionScorer in the .zip attachment, I'm
 sorry I did not see this earlier when I posted on java-dev about this.

 The problem is that MaxDisjunctionScorer uses bubble sort to keep the subscorer
 sorted over the documents in the next() method (line 103), and this does not scale nicely
 when the number of subscorers increases.
 Supposing the number of subscores that match the document is N,
 the amount of work to be done is proportional to (N*N) per document.
 In DisjunctionSumScorer a priority queue is used, and there the amount of work is
 proportional to (N log(N)) per document.
 So I would recommend to rewrite MaxDisjunctionScorer to inherit from a new common
 super class with DisjunctionSumScorer, sharing everything except the
 advanceAfterCurrent() method (which could be abstract in the new superclass).
 It's possible to be more aggressive in refactoring by initializing and adapting
 the score per index document using different methods, but this would take N
 extra method calls per document.

 At the same time the name could be changed to DisjunctionMaxScorer
 for consistency in the org.lucene.search package.

 Regards,
 Paul Elschot

 Comment by Chuck Williams [14/Nov/05 11:55 PM]
 The code only uses bubble sort for the incremental resorting of an already-sorted list. The initial sort is done with Arrays.sort() which is O(n*logn). The incremental resort is O(k*n) where k is the number of clauses that match the document last generated. Even if n is large, k will usually be small. Theoretically this is O(n^2) because k could be as high as n, but this is extremely unlikely especially when n is large. More likely is that k is bounded by a small constant, in which case the algorithm is O(n). It's like Quicksort in that regard -- there are outlier cases where it won't perform well, but it will perform better than most alternatives for the vast majority of cases.

 Resorting the whole list every time would perform worse. The best algorithm would probably be to use the standard insert and delete operations on a heap (as in heap sort):

   while top element generated last doc
       heap remove it
       generate it
       heap insert it

 This would yield total time O(k*logn), as with a PriorityQueue.

 I don't think this is much of an issue to worry about, but the algorithm could be revised to use the heap sort operations if others think it is important.

 Chuck

*********************************************************************/